<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Grifo Tools — Conversor WebP (MVP)</title>
  <meta name="description" content="Conversor & Compressor de Imagens para WebP — 100% client-side. Privado, rápido e acessível." />

  <!-- Tailwind via CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    // Tema escuro com bom contraste
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            brand: {
              50:'#EFF6FF',100:'#DBEAFE',200:'#BFDBFE',300:'#93C5FD',400:'#60A5FA',500:'#3B82F6',600:'#2563EB',700:'#1D4ED8',800:'#1E40AF',900:'#1E3A8A'
            }
          }
        }
      }
    }
  </script>
  <!-- JSZip para gerar ZIP -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <style>
    /* Suaviza rolagem quando barras avançam */
    html { scroll-behavior: smooth; }
    /* Foco visível reforçado */
    :focus { outline: 2px solid #60A5FA; outline-offset: 2px; }
  </style>
</head>
<body class="min-h-screen bg-neutral-950 text-neutral-100 selection:bg-brand-500/30">
  <header class="border-b border-neutral-800 bg-neutral-900/60 backdrop-blur supports-[backdrop-filter]:bg-neutral-900/40 sticky top-0 z-50">
    <div class="max-w-7xl mx-auto px-4 py-3 flex items-center gap-3">
      <a href="https://grifo.agency" target="_blank" rel="noopener" class="shrink-0" aria-label="Visitar site da Grifo">
        <img id="logoImg" src="logo.png" alt="Grifo" class="h-8 w-auto" onerror="this.style.display='none';document.getElementById('logoFallback').classList.remove('hidden')" />
        <span id="logoFallback" class="hidden font-semibold text-brand-400">Grifo</span>
      </a>
      <div class="flex-1"></div>
      <h1 class="text-sm md:text-base font-medium text-neutral-200">Conversor WebP — MVP 100% client‑side</h1>
    </div>
  </header>

  <main class="max-w-7xl mx-auto px-4 py-6 grid md:grid-cols-12 gap-6">
    <!-- Coluna esquerda: Dropzone + Configs -->
    <section class="md:col-span-4 space-y-6">
      <!-- Dropzone -->
      <div id="dropzone" class="border-2 border-dashed border-neutral-700 rounded-2xl p-6 text-center bg-neutral-900/40 hover:border-brand-500 transition cursor-pointer">
        <div class="space-y-2">
          <p class="text-neutral-300">Arraste & solte imagens aqui</p>
          <p class="text-neutral-500 text-sm">ou</p>
          <label for="fileInput" class="inline-flex items-center gap-2 px-4 py-2 rounded-xl bg-brand-600 hover:bg-brand-500 text-white text-sm font-medium cursor-pointer">Selecionar arquivos</label>
          <input id="fileInput" type="file" accept="image/png,image/jpeg,image/webp" multiple class="hidden" />
          <p id="queueInfo" class="text-xs text-neutral-500">Nenhum arquivo adicionado</p>
        </div>
      </div>

      <!-- Configurações (accordion no mobile) -->
      <details class="group md:open" open>
        <summary class="list-none select-none cursor-pointer flex items-center justify-between bg-neutral-900/60 border border-neutral-800 rounded-2xl px-4 py-3">
          <span class="font-medium">Configurações</span>
          <span class="text-neutral-400 group-open:rotate-180 transition">▾</span>
        </summary>
        <div class="p-4 border border-neutral-800 border-t-0 rounded-b-2xl bg-neutral-900/40 space-y-4">
          <div>
            <label class="block text-sm text-neutral-300 mb-1">Formato de saída</label>
            <input type="text" value="WebP" disabled class="w-full px-3 py-2 rounded-lg bg-neutral-800/70 border border-neutral-700 text-neutral-300 text-sm" />
          </div>
          <div>
            <label for="quality" class="block text-sm text-neutral-300 mb-1">Qualidade (1–100)</label>
            <div class="flex items-center gap-3">
              <input id="quality" type="range" min="1" max="100" value="85" class="w-full" />
              <input id="qualityInput" type="number" min="1" max="100" value="85" class="w-20 px-3 py-2 rounded-lg bg-neutral-800/70 border border-neutral-700 text-neutral-100 text-sm" />
            </div>
          </div>
          <div class="space-y-2">
            <label class="inline-flex items-center gap-2">
              <input id="resizeToggle" type="checkbox" class="accent-brand-500" checked />
              <span class="text-sm">Redimensionar (não ampliar)</span>
            </label>
            <div class="grid grid-cols-2 gap-3">
              <div>
                <label for="maxW" class="block text-xs text-neutral-400 mb-1">Máx. Largura (px)</label>
                <input id="maxW" type="number" min="1" value="1920" class="w-full px-3 py-2 rounded-lg bg-neutral-800/70 border border-neutral-700 text-neutral-100 text-sm" />
              </div>
              <div>
                <label for="maxH" class="block text-xs text-neutral-400 mb-1">Máx. Altura (px)</label>
                <input id="maxH" type="number" min="1" value="1080" class="w-full px-3 py-2 rounded-lg bg-neutral-800/70 border border-neutral-700 text-neutral-100 text-sm" />
              </div>
            </div>
          </div>
          <div>
            <label class="inline-flex items-center gap-2">
              <input id="stripMeta" type="checkbox" class="accent-brand-500" checked />
              <span class="text-sm">Remover metadata (EXIF/ICC)</span>
            </label>
          </div>
          <div class="flex items-center gap-3">
            <button id="savePreset" class="px-3 py-2 rounded-xl bg-neutral-800 hover:bg-neutral-700 border border-neutral-700 text-sm">Salvar preset</button>
            <select id="applyPreset" class="px-3 py-2 rounded-xl bg-neutral-800/70 border border-neutral-700 text-sm text-neutral-100 min-w-[10rem]">
              <option value="">Aplicar preset…</option>
            </select>
            <button id="deletePreset" class="px-3 py-2 rounded-xl bg-neutral-800 hover:bg-neutral-700 border border-neutral-700 text-sm">Excluir preset</button>
          </div>
          <div class="border-t border-neutral-800 pt-3">
            <label for="concurrency" class="block text-sm text-neutral-300 mb-1">Avançado — Concorrência</label>
            <input id="concurrency" type="number" min="1" max="8" value="3" class="w-24 px-3 py-2 rounded-lg bg-neutral-800/70 border border-neutral-700 text-neutral-100 text-sm" />
            <p class="text-xs text-neutral-500 mt-1">Padrão: 3. Aumentar pode exigir mais memória.</p>
          </div>
        </div>
      </details>

      <div class="text-xs text-neutral-500">
        Limites: até 500 arquivos/lote; 50–100MB/arquivo; até 12.000px no maior lado; ZIP recomendado &lt; 500MB.
      </div>
    </section>

    <!-- Coluna direita: Lista de arquivos -->
    <section class="md:col-span-8 space-y-4">
      <div class="flex flex-wrap items-center gap-2">
        <button id="btnConvert" class="px-4 py-2 rounded-xl bg-brand-600 hover:bg-brand-500 text-white text-sm font-medium">Converter</button>
        <button id="btnPause" class="px-4 py-2 rounded-xl bg-neutral-800 hover:bg-neutral-700 border border-neutral-700 text-sm">Pausar</button>
        <button id="btnResume" class="px-4 py-2 rounded-xl bg-neutral-800 hover:bg-neutral-700 border border-neutral-700 text-sm">Retomar</button>
        <button id="btnClear" class="px-4 py-2 rounded-xl bg-neutral-800 hover:bg-neutral-700 border border-neutral-700 text-sm">Limpar fila</button>
        <button id="btnZip" class="px-4 py-2 rounded-xl bg-neutral-800 hover:bg-neutral-700 border border-neutral-700 text-sm">Baixar ZIP</button>
      </div>

      <div class="bg-neutral-900/40 border border-neutral-800 rounded-2xl p-4">
        <div class="flex items-center justify-between mb-2">
          <h2 class="font-medium">Arquivos</h2>
          <span id="summary" class="text-sm text-neutral-400">0 itens</span>
        </div>
        <ul id="fileList" class="space-y-3"></ul>
        <div class="mt-4">
          <label class="block text-xs text-neutral-400 mb-1">Progresso total</label>
          <div class="w-full h-2 bg-neutral-800 rounded-full overflow-hidden">
            <div id="totalBar" class="h-2 bg-brand-600 transition-[width] duration-200" style="width:0%"></div>
          </div>
          <div id="totalText" class="mt-1 text-xs text-neutral-400">0/0 concluídos (0%)</div>
        </div>
      </div>

      <div aria-live="polite" id="statusLive" class="text-sm text-neutral-300"></div>
    </section>
  </main>

  <!-- Barra sticky no mobile -->
  <div class="md:hidden fixed bottom-0 inset-x-0 border-t border-neutral-800 bg-neutral-900/80 backdrop-blur p-3">
    <div class="max-w-7xl mx-auto flex items-center justify-between gap-2">
      <button id="mConvert" class="px-3 py-2 rounded-xl bg-brand-600 hover:bg-brand-500 text-white text-sm font-medium">Converter</button>
      <button id="mPause" class="px-3 py-2 rounded-xl bg-neutral-800 hover:bg-neutral-700 border border-neutral-700 text-sm">Pausar</button>
      <button id="mResume" class="px-3 py-2 rounded-xl bg-neutral-800 hover:bg-neutral-700 border border-neutral-700 text-sm">Retomar</button>
      <button id="mZip" class="px-3 py-2 rounded-xl bg-neutral-800 hover:bg-neutral-700 border border-neutral-700 text-sm">ZIP</button>
    </div>
  </div>

  <footer class="max-w-7xl mx-auto px-4 py-10 text-xs text-neutral-500">
    100% client-side · Sem coleta de dados · Feito para a Grifo Agency
  </footer>

  <script>
  // =====================
  // Utilidades & Estado
  // =====================
  const $ = (sel) => document.querySelector(sel);
  const $$ = (sel) => Array.from(document.querySelectorAll(sel));

  const fileInput = $('#fileInput');
  const dropzone = $('#dropzone');
  const fileList = $('#fileList');
  const queueInfo = $('#queueInfo');
  const totalBar = $('#totalBar');
  const totalText = $('#totalText');
  const summary = $('#summary');
  const statusLive = $('#statusLive');

  const btns = {
    convert: $('#btnConvert'), pause: $('#btnPause'), resume: $('#btnResume'), clear: $('#btnClear'), zip: $('#btnZip'),
    mConvert: $('#mConvert'), mPause: $('#mPause'), mResume: $('#mResume'), mZip: $('#mZip')
  };

  const qualityRange = $('#quality');
  const qualityInput = $('#qualityInput');
  const resizeToggle = $('#resizeToggle');
  const maxW = $('#maxW');
  const maxH = $('#maxH');
  const stripMeta = $('#stripMeta');
  const concurrencyInput = $('#concurrency');
  const savePresetBtn = $('#savePreset');
  const applyPresetSel = $('#applyPreset');
  const deletePresetBtn = $('#deletePreset');

  const LIMITS = {
    MAX_FILES: 500,
    MAX_FILE_MB: 100, // aceitar 50–100MB; usamos 100MB como teto
    MAX_SIDE: 12000
  };

  // Suporte a WebP
  let webpSupported = (function(){
    try {
      const c = document.createElement('canvas');
      return c.toDataURL && c.toDataURL('image/webp').indexOf('data:image/webp') === 0;
    } catch(e) { return false; }
  })();
  if(!webpSupported){
    alert('Seu navegador não suporta WebP. Use Chrome/Edge/Firefox/Safari recente.');
  }

  // Estado da fila
  const state = {
    items: [],              // { id, file, name, origBytes, status, progress, stage, resultBlob, url }
    nextId: 1,
    running: 0,
    paused: false,
    concurrency: 3,
    zip: new JSZip()
  };

  // Presets (localStorage)
  const PRESETS_KEY = 'grifo_webp_presets_v1';
  function loadPresets(){
    const raw = localStorage.getItem(PRESETS_KEY);
    const list = raw ? JSON.parse(raw) : {};
    applyPresetSel.innerHTML = '<option value="">Aplicar preset…</option>' +
      Object.keys(list).map(k=>`<option value="${k}">${k}</option>`).join('');
    return list;
  }
  function savePreset(name){
    const list = loadPresets();
    list[name] = {
      q: Number(qualityInput.value),
      resize: resizeToggle.checked,
      mw: Number(maxW.value),
      mh: Number(maxH.value),
      cc: Number(concurrencyInput.value)
    };
    localStorage.setItem(PRESETS_KEY, JSON.stringify(list));
    loadPresets();
  }
  function deletePreset(name){
    const list = loadPresets();
    delete list[name];
    localStorage.setItem(PRESETS_KEY, JSON.stringify(list));
    loadPresets();
  }
  loadPresets();

  // Sincronizar qualidade range/input
  qualityRange.addEventListener('input', () => qualityInput.value = qualityRange.value);
  qualityInput.addEventListener('input', () => {
    let v = Math.max(1, Math.min(100, Number(qualityInput.value)||85));
    qualityInput.value = v; qualityRange.value = v;
  });

  // Importar arquivos
  dropzone.addEventListener('click', () => fileInput.click());
  dropzone.addEventListener('dragover', (e)=>{ e.preventDefault(); dropzone.classList.add('border-brand-500'); });
  dropzone.addEventListener('dragleave', ()=> dropzone.classList.remove('border-brand-500'));
  dropzone.addEventListener('drop', (e)=>{
    e.preventDefault(); dropzone.classList.remove('border-brand-500');
    addFiles(e.dataTransfer.files);
  });
  fileInput.addEventListener('change', ()=> addFiles(fileInput.files));

  function addFiles(fileListLike){
    const files = Array.from(fileListLike || []);
    if(!files.length) return;

    const currentCount = state.items.length;
    const allowed = Math.max(0, LIMITS.MAX_FILES - currentCount);
    const toAdd = files.slice(0, allowed);
    if(files.length > toAdd.length) alert(`Limite de ${LIMITS.MAX_FILES} arquivos por lote. ${files.length - toAdd.length} não foram adicionados.`);

    toAdd.forEach(file => {
      if(!/^image\/(png|jpe?g|webp)$/i.test(file.type)){
        notify(`Tipo não suportado: ${file.name}`);
        return;
      }
      const mb = file.size / (1024*1024);
      if(mb > LIMITS.MAX_FILE_MB){
        notify(`Arquivo muito grande (> ${LIMITS.MAX_FILE_MB}MB): ${file.name}`);
        return;
      }
      const id = state.nextId++;
      const item = { id, file, name: file.name, origBytes: file.size, status:'Fila', progress:0, stage:'', resultBlob:null, url:null };
      state.items.push(item);
      renderItem(item);
    });
    updateSummary();
  }

  function renderItem(item){
    const li = document.createElement('li');
    li.id = `item-${item.id}`;
    li.className = 'p-3 rounded-xl border border-neutral-800 bg-neutral-900/40';
    li.innerHTML = `
      <div class="flex items-center gap-3">
        <div class="h-14 w-14 rounded-lg overflow-hidden bg-neutral-800 shrink-0">
          <img alt="miniatura" class="h-full w-full object-cover" />
        </div>
        <div class="flex-1 min-w-0">
          <div class="flex items-center justify-between gap-2">
            <div class="truncate text-sm"><span class="text-neutral-200 truncate inline-block max-w-[18rem]" title="${item.name}">${item.name}</span></div>
            <div class="text-xs text-neutral-400" id="size-${item.id}">${fmtBytes(item.origBytes)}</div>
          </div>
          <div class="mt-2 w-full h-2 bg-neutral-800 rounded-full overflow-hidden">
            <div id="bar-${item.id}" class="h-2 bg-brand-600 transition-[width] duration-200" style="width:0%"></div>
          </div>
          <div class="mt-1 text-xs text-neutral-400 flex items-center justify-between">
            <span id="stage-${item.id}">Fila</span>
            <span id="eco-${item.id}"></span>
          </div>
        </div>
        <div class="flex flex-col gap-2">
          <a id="dl-${item.id}" class="px-3 py-2 rounded-lg bg-neutral-800 border border-neutral-700 text-xs text-neutral-200 pointer-events-none opacity-40 text-center">Baixar</a>
          <button id="re-${item.id}" class="px-3 py-2 rounded-lg bg-neutral-800 border border-neutral-700 text-xs">Reprocessar</button>
        </div>
      </div>`;
    fileList.appendChild(li);

    // Miniatura
    const imgTag = li.querySelector('img');
    const r = new FileReader(); r.onload = () => imgTag.src = r.result; r.readAsDataURL(item.file);

    // Handlers
    li.querySelector(`#re-${item.id}`).addEventListener('click', ()=>{
      // zera resultado e recoloca na fila
      if(item.url){ URL.revokeObjectURL(item.url); item.url = null; }
      item.resultBlob = null; item.status='Fila'; item.progress=0; item.stage='';
      updateItem(item);
      schedule();
    });
  }

  function updateItem(item){
    const bar = $(`#bar-${item.id}`);
    const stage = $(`#stage-${item.id}`);
    const eco = $(`#eco-${item.id}`);
    const size = $(`#size-${item.id}`);
    const dl = $(`#dl-${item.id}`);

    if(bar) bar.style.width = `${Math.floor(item.progress)}%`;
    if(stage) stage.textContent = item.stage || '';

    if(item.resultBlob){
      const saving = item.origBytes - item.resultBlob.size;
      const pct = item.origBytes ? (saving / item.origBytes) * 100 : 0;
      eco.textContent = `${fmtBytes(item.origBytes)} → ${fmtBytes(item.resultBlob.size)} (${pct>0?'-':''}${pct.toFixed(0)}%)`;
      size.textContent = fmtBytes(item.resultBlob.size);
      dl.classList.remove('opacity-40','pointer-events-none');
      if(!item.url){ item.url = URL.createObjectURL(item.resultBlob); }
      dl.href = item.url; dl.download = toWebpName(item.name);
    }
  }

  function updateSummary(){
    const total = state.items.length;
    const done = state.items.filter(i=>i.status==='Concluído').length;
    summary.textContent = `${total} itens · ${done} concluídos`;
    queueInfo.textContent = total ? `${total} arquivo(s) na fila` : 'Nenhum arquivo adicionado';
    const avg = total? (state.items.reduce((a,i)=>a + (i.progress||0),0) / total) : 0;
    totalBar.style.width = `${avg.toFixed(0)}%`;
    totalText.textContent = `${done}/${total} concluídos (${avg.toFixed(0)}%)`;
  }

  function notify(msg){ statusLive.textContent = msg; }

  function fmtBytes(b){
    if(b===0) return '0 B';
    const k = 1024, sizes=['B','KB','MB','GB'];
    const i = Math.floor(Math.log(b)/Math.log(k));
    return (b/Math.pow(k,i)).toFixed(1)+' '+sizes[i];
  }

  function toWebpName(name){
    const base = name.replace(/\.[^.]+$/, '');
    return base + '.webp';
  }

  // =====================
  // Pipeline de processamento
  // =====================
  function settings(){
    const q = Math.max(1, Math.min(100, Number(qualityInput.value)||85));
    const quality = Math.max(0.01, Math.min(1, q/100));
    const resize = !!resizeToggle.checked;
    const mw = Math.max(1, Number(maxW.value)||1920);
    const mh = Math.max(1, Number(maxH.value)||1080);
    const cc = Math.max(1, Math.min(8, Number(concurrencyInput.value)||3));
    state.concurrency = cc;
    return { quality, resize, mw, mh };
  }

  async function processItem(item){
    const { quality, resize, mw, mh } = settings();

    const update = (pct, stage) => { item.progress = pct; item.stage = stage; updateItem(item); updateSummary(); };
    try{
      item.status = 'Processando'; update(5, 'Preparando…'); await new Promise(r=>requestAnimationFrame(r));

      // 1) Carregar/decodificar
      update(20, 'Carregando imagem…');
      let imgEl = new Image();
      const dataURL = await fileToDataURL(item.file);
      await new Promise((res, rej)=>{ imgEl.onload = ()=>res(); imgEl.onerror = (e)=>rej(new Error('Falha ao decodificar imagem')); imgEl.src = dataURL; });
      const srcW = imgEl.naturalWidth, srcH = imgEl.naturalHeight;

      // Checagem de limite máximo de lado
      const maxSide = Math.max(srcW, srcH);
      if(maxSide > LIMITS.MAX_SIDE && !resize){
        throw new Error(`Maior lado (${maxSide}px) excede ${LIMITS.MAX_SIDE}px e redimensionamento está desligado.`);
      }

      // 2) Redimensionar (se necessário)
      let targetW = srcW, targetH = srcH;
      const limitW = Math.min(mw, LIMITS.MAX_SIDE);
      const limitH = Math.min(mh, LIMITS.MAX_SIDE);
      if(resize && (srcW > limitW || srcH > limitH)){
        const ratio = Math.min(limitW/srcW, limitH/srcH);
        targetW = Math.max(1, Math.floor(srcW * ratio));
        targetH = Math.max(1, Math.floor(srcH * ratio));
      }
      // mesmo se resize off, se exceder LIMITE ABSOLUTO, clamp até 12k (segurança)
      if(!resize && Math.max(targetW,targetH) > LIMITS.MAX_SIDE){
        const r = LIMITS.MAX_SIDE / Math.max(targetW,targetH);
        targetW = Math.floor(targetW*r); targetH = Math.floor(targetH*r);
      }
      update(50, resize ? `Redimensionando para ${targetW}×${targetH}…` : 'Mantendo dimensões…');

      const canvas = document.createElement('canvas');
      canvas.width = targetW; canvas.height = targetH;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(imgEl, 0, 0, targetW, targetH);
      imgEl.src = ''; imgEl = null; // libera

      // 3) Comprimir WebP
      update(90, `Comprimindo (qualidade ${(quality*100).toFixed(0)}%)…`);
      const blob = await canvasToWebP(canvas, quality);

      // 4) Finalizar
      item.resultBlob = blob; item.status = 'Concluído'; update(100, 'Concluído');

      // Limpeza de memória
      ctx && ctx.reset && ctx.reset();
    } catch(err){
      item.status = 'Erro'; item.stage = 'Erro'; notify(err.message || 'Erro no processamento');
    }
  }

  function fileToDataURL(file){
    return new Promise((res, rej)=>{
      const r = new FileReader();
      r.onload = ()=> res(r.result);
      r.onerror = ()=> rej(new Error('Falha ao ler arquivo'));
      r.readAsDataURL(file);
    });
  }

  function canvasToWebP(canvas, quality){
    return new Promise((res, rej)=>{
      if(canvas.toBlob){
        canvas.toBlob((b)=>{
          if(!b){ rej(new Error('Falha ao gerar WebP')); return; }
          res(b);
        }, 'image/webp', quality);
      } else {
        try{
          const dataURL = canvas.toDataURL('image/webp', quality);
          const b = dataURLToBlob(dataURL);
          res(b);
        }catch(e){ rej(new Error('Conversão WebP não suportada')); }
      }
    });
  }

  function dataURLToBlob(dataURL){
    const parts = dataURL.split(',');
    const mime = parts[0].match(/:(.*?);/)[1];
    const bstr = atob(parts[1]);
    let n = bstr.length; const u8 = new Uint8Array(n);
    while(n--){ u8[n] = bstr.charCodeAt(n); }
    return new Blob([u8], { type: mime });
  }

  // =====================
  // Scheduler (concorrência fixa)
  // =====================
  function schedule(){
    if(state.paused) return;
    const conc = state.concurrency;
    while(state.running < conc){
      const next = state.items.find(i=>i.status==='Fila');
      if(!next) break;
      state.running++;
      processItem(next).finally(()=>{
        state.running--;
        // Atualiza UI do item
        updateItem(next);
        updateSummary();
        // Encadear próximo
        schedule();
      });
    }
  }

  // =====================
  // Ações globais
  // =====================
  function convertAll(){
    if(!state.items.length){ notify('Adicione arquivos primeiro.'); return; }
    state.paused = false; schedule(); notify('Conversão iniciada.');
  }
  function pause(){ state.paused = true; notify('Pausado (novos itens não iniciam).'); }
  function resume(){ if(!state.items.length){ notify('Nenhum item na fila.'); return; } state.paused = false; schedule(); notify('Retomado.'); }
  function clearQueue(){
    // Mantém os que estão processando/Concluídos? Vamos limpar tudo.
    state.items.forEach(i=>{ if(i.url) URL.revokeObjectURL(i.url); });
    state.items = []; state.running = 0; state.paused = false; state.zip = new JSZip();
    fileList.innerHTML = ''; updateSummary(); notify('Fila limpa.');
  }
  async function downloadZip(){
    const done = state.items.filter(i=>i.status==='Concluído' && i.resultBlob);
    if(!done.length){ notify('Não há arquivos concluídos para zipar.'); return; }
    const zip = new JSZip();
    done.forEach(i=> zip.file(toWebpName(i.name), i.resultBlob));
    notify('Gerando ZIP…');
    const blob = await zip.generateAsync({ type:'blob' }, (meta)=>{
      totalText.textContent = `Compactando: ${(meta.percent||0).toFixed(0)}%`;
    });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    const ts = new Date().toISOString().replace(/[-:T]/g,'').slice(0,12);
    a.href = url; a.download = `webp_batch_${ts}.zip`; a.click();
    setTimeout(()=> URL.revokeObjectURL(url), 10000);
    notify('ZIP gerado.');
  }

  // Bind botões (desktop e mobile)
  [btns.convert, btns.mConvert].forEach(b=> b.addEventListener('click', convertAll));
  [btns.pause, btns.mPause].forEach(b=> b.addEventListener('click', pause));
  [btns.resume, btns.mResume].forEach(b=> b.addEventListener('click', resume));
  btns.clear.addEventListener('click', clearQueue);
  [btns.zip, btns.mZip].forEach(b=> b.addEventListener('click', downloadZip));

  // Presets
  savePresetBtn.addEventListener('click', ()=>{
    const name = prompt('Nome do preset:'); if(!name) return; savePreset(name); notify(`Preset "${name}" salvo.`);
  });
  applyPresetSel.addEventListener('change', ()=>{
    const name = applyPresetSel.value; if(!name) return;
    const list = loadPresets(); const p = list[name]; if(!p) return;
    qualityInput.value = p.q; qualityRange.value = p.q;
    resizeToggle.checked = !!p.resize; maxW.value = p.mw; maxH.value = p.mh;
    concurrencyInput.value = p.cc; settings();
    notify(`Preset "${name}" aplicado.`);
  });
  deletePresetBtn.addEventListener('click', ()=>{
    const name = applyPresetSel.value; if(!name) { alert('Selecione um preset para excluir.'); return; }
    if(confirm(`Excluir preset "${name}"?`)){ deletePreset(name); notify('Preset excluído.'); }
  });

  // Acessibilidade extra: teclas de atalho
  window.addEventListener('keydown', (e)=>{
    if(e.key==='Enter' && (e.ctrlKey||e.metaKey)) convertAll();
    if(e.key==='Escape') pause();
  });
  </script>
</body>
</html>
```
